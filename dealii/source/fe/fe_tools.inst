// This file is automatically generated from corresponding .inst.in, do not edit.

#ifdef SPLIT_INSTANTIATIONS_COUNT
  #define SPLIT_INSTANTIATIONS_CHECK(C) (((C) % SPLIT_INSTANTIATIONS_COUNT) == SPLIT_INSTANTIATIONS_INDEX)
#else
  #define SPLIT_INSTANTIATIONS_CHECK(C) (1)
#endif

#if (SPLIT_INSTANTIATIONS_CHECK(0))
namespace FETools
 {
#if  1  <=  1 
 namespace Compositing
 {
 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 1 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const FiniteElement< 1 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 1 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 1 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 1 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 1 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  1 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 1 ,  1 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 1 ,  1 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 1 ,  1 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 1 ,
 double,
  1 >(
 const FiniteElement< 1 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 1 ,
 double,
  1 >(
 const FiniteElement< 1 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(1))
namespace FETools
 {
#if  1  <=  2 
 namespace Compositing
 {
 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 1 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const FiniteElement< 1 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 1 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 1 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 1 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 1 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  2 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 1 ,  2 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 1 ,  2 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 1 ,  2 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 1 ,
 double,
  2 >(
 const FiniteElement< 1 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 1 ,
 double,
  2 >(
 const FiniteElement< 1 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(2))
namespace FETools
 {
#if  1  <=  3 
 namespace Compositing
 {
 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 1 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 1 >
 multiply_dof_numbers(
 const FiniteElement< 1 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 1 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 1 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 1 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 1 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 1 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 1 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 1 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 1 ,  3 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 1 ,  3 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 1 ,  3 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 1 ,  3 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 1 ,
 double,
  3 >(
 const FiniteElement< 1 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 1 ,
 double,
  3 >(
 const FiniteElement< 1 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(3))
namespace FETools
 {
#if  2  <=  1 
 namespace Compositing
 {
 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 2 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const FiniteElement< 2 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 2 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 2 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 2 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 2 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  1 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 2 ,  1 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 2 ,  1 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 2 ,  1 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 2 ,
 double,
  1 >(
 const FiniteElement< 2 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 2 ,
 double,
  1 >(
 const FiniteElement< 2 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(4))
namespace FETools
 {
#if  2  <=  2 
 namespace Compositing
 {
 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 2 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const FiniteElement< 2 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 2 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 2 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 2 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 2 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  2 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 2 ,  2 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 2 ,  2 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 2 ,  2 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 2 ,
 double,
  2 >(
 const FiniteElement< 2 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 2 ,
 double,
  2 >(
 const FiniteElement< 2 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(5))
namespace FETools
 {
#if  2  <=  3 
 namespace Compositing
 {
 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 2 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 2 >
 multiply_dof_numbers(
 const FiniteElement< 2 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 2 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 2 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 2 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 2 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 2 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 2 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 2 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 2 ,  3 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 2 ,  3 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 2 ,  3 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 2 ,  3 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 2 ,
 double,
  3 >(
 const FiniteElement< 2 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 2 ,
 double,
  3 >(
 const FiniteElement< 2 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(6))
namespace FETools
 {
#if  3  <=  1 
 namespace Compositing
 {
 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 3 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const FiniteElement< 3 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 3 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 3 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  1 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 3 ,  1 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 3 ,  1 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  1 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  1 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  1 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  1 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 3 ,  1 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 3 ,  1 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 3 ,  1 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 3 ,
 double,
  1 >(
 const FiniteElement< 3 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 3 ,
 double,
  1 >(
 const FiniteElement< 3 ,  1 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(7))
namespace FETools
 {
#if  3  <=  2 
 namespace Compositing
 {
 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 3 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const FiniteElement< 3 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 3 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 3 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  2 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 3 ,  2 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 3 ,  2 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  2 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  2 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  2 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  2 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 3 ,  2 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 3 ,  2 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 3 ,  2 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 3 ,
 double,
  2 >(
 const FiniteElement< 3 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 3 ,
 double,
  2 >(
 const FiniteElement< 3 ,  2 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(8))
namespace FETools
 {
#if  3  <=  3 
 namespace Compositing
 {
 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const std::vector<
 const FiniteElement< 3 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 bool);

 template FiniteElementData< 3 >
 multiply_dof_numbers(
 const FiniteElement< 3 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const std::vector<
 const FiniteElement< 3 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities);

 template std::vector<bool>
 compute_restriction_is_additive_flags(
 const FiniteElement< 3 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  3 > *fe5,
 const unsigned int N5);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const std::vector<
 const FiniteElement< 3 ,  3 > *>
 & fes,
 const std::vector<unsigned int> &multiplicities,
 const bool do_tensor_product);

 template std::vector<ComponentMask>
 compute_nonzero_components(
 const FiniteElement< 3 ,  3 > *fe1,
 const unsigned int N1,
 const FiniteElement< 3 ,  3 > *fe2,
 const unsigned int N2,
 const FiniteElement< 3 ,  3 > *fe3,
 const unsigned int N3,
 const FiniteElement< 3 ,  3 > *fe4,
 const unsigned int N4,
 const FiniteElement< 3 ,  3 > *fe5,
 const unsigned int N5,
 const bool);

 template void
 build_cell_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 & system_to_component_table,
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &component_to_base_table,
 const FiniteElement< 3 ,  3 > &fe,
 const bool do_tensor_product);

 template void
 build_face_tables(
 std::vector<std::pair<std::pair<unsigned int, unsigned int>,
 unsigned int>> &face_system_to_base_table,
 std::vector<std::pair<unsigned int, unsigned int>>
 &face_system_to_component_table,
 const FiniteElement< 3 ,  3 > &fe,
 const bool do_tensor_product,
 const unsigned int face_no);

 }

 template void
 compute_block_renumbering(
 const FiniteElement< 3 ,  3 > &,
 std::vector<types::global_dof_index> &,
 std::vector<types::global_dof_index> &,
 bool);

 template void
 compute_projection_matrices< 3 ,
 double,
  3 >(
 const FiniteElement< 3 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 bool);

 template void
 compute_embedding_matrices< 3 ,
 double,
  3 >(
 const FiniteElement< 3 ,  3 > &,
 std::vector<std::vector<FullMatrix<double>>> &,
 const bool,
 const double);
#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(9))
namespace FETools
 {

#if  1  <=  1 
 template void
 get_interpolation_matrix< 1 ,
 double,
  1 >(
 const FiniteElement< 1 ,  1 > &,
 const FiniteElement< 1 ,  1 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 1 ,  1 >>
 get_fe_by_name< 1 ,  1 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 1 ,  1 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 1 ,  1 > &,
 const Quadrature< 1 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);
#endif

#if  1  ==  1 

 template class FEFactoryBase< 1 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 1 > &);

 template void
 compute_component_wise(const FiniteElement< 1 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 1 , double>(
 const FiniteElement< 1 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 1 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  1 >> &,
 std::vector<Tensor<1,  1 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  1 >> &,
 std::vector<SymmetricTensor<2,  1 >> &);

# if  1  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 1 > &,
 const Quadrature< 1  - 1> &,
 const Quadrature< 1  - 1> &,
 const DoFHandler< 1 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 1 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 1 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(10))
namespace FETools
 {

#if  1  <=  2 
 template void
 get_interpolation_matrix< 1 ,
 double,
  2 >(
 const FiniteElement< 1 ,  2 > &,
 const FiniteElement< 1 ,  2 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 1 ,  2 >>
 get_fe_by_name< 1 ,  2 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 1 ,  2 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 1 ,  2 > &,
 const Quadrature< 1 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);
#endif

#if  1  ==  2 

 template class FEFactoryBase< 1 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 1 > &);

 template void
 compute_component_wise(const FiniteElement< 1 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 1 , double>(
 const FiniteElement< 1 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 1 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  1 >> &,
 std::vector<Tensor<1,  1 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  1 >> &,
 std::vector<SymmetricTensor<2,  1 >> &);

# if  1  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 1 > &,
 const Quadrature< 1  - 1> &,
 const Quadrature< 1  - 1> &,
 const DoFHandler< 1 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 1 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 1 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(11))
namespace FETools
 {

#if  1  <=  3 
 template void
 get_interpolation_matrix< 1 ,
 double,
  3 >(
 const FiniteElement< 1 ,  3 > &,
 const FiniteElement< 1 ,  3 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 1 ,  3 >>
 get_fe_by_name< 1 ,  3 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 1 ,  3 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 1 ,  3 > &,
 const Quadrature< 1 > &,
 const Quadrature< 1 > &,
 FullMatrix<double> &);
#endif

#if  1  ==  3 

 template class FEFactoryBase< 1 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 1 > &);

 template void
 compute_component_wise(const FiniteElement< 1 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 1 >(
 const FiniteElement< 1 > &,
 const FiniteElement< 1 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 1 , double>(
 const FiniteElement< 1 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 1 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  1 >> &,
 std::vector<Tensor<1,  1 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  1 >> &,
 std::vector<SymmetricTensor<2,  1 >> &);

# if  1  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 1 > &,
 const Quadrature< 1  - 1> &,
 const Quadrature< 1  - 1> &,
 const DoFHandler< 1 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 1 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 1 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(12))
namespace FETools
 {

#if  2  <=  1 
 template void
 get_interpolation_matrix< 2 ,
 double,
  1 >(
 const FiniteElement< 2 ,  1 > &,
 const FiniteElement< 2 ,  1 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 2 ,  1 >>
 get_fe_by_name< 2 ,  1 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 2 ,  1 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 2 ,  1 > &,
 const Quadrature< 2 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);
#endif

#if  2  ==  1 

 template class FEFactoryBase< 2 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 2 > &);

 template void
 compute_component_wise(const FiniteElement< 2 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 2 , double>(
 const FiniteElement< 2 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 2 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  2 >> &,
 std::vector<Tensor<1,  2 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  2 >> &,
 std::vector<SymmetricTensor<2,  2 >> &);

# if  2  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 2 > &,
 const Quadrature< 2  - 1> &,
 const Quadrature< 2  - 1> &,
 const DoFHandler< 2 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 2 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 2 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(13))
namespace FETools
 {

#if  2  <=  2 
 template void
 get_interpolation_matrix< 2 ,
 double,
  2 >(
 const FiniteElement< 2 ,  2 > &,
 const FiniteElement< 2 ,  2 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 2 ,  2 >>
 get_fe_by_name< 2 ,  2 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 2 ,  2 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 2 ,  2 > &,
 const Quadrature< 2 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);
#endif

#if  2  ==  2 

 template class FEFactoryBase< 2 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 2 > &);

 template void
 compute_component_wise(const FiniteElement< 2 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 2 , double>(
 const FiniteElement< 2 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 2 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  2 >> &,
 std::vector<Tensor<1,  2 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  2 >> &,
 std::vector<SymmetricTensor<2,  2 >> &);

# if  2  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 2 > &,
 const Quadrature< 2  - 1> &,
 const Quadrature< 2  - 1> &,
 const DoFHandler< 2 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 2 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 2 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(14))
namespace FETools
 {

#if  2  <=  3 
 template void
 get_interpolation_matrix< 2 ,
 double,
  3 >(
 const FiniteElement< 2 ,  3 > &,
 const FiniteElement< 2 ,  3 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 2 ,  3 >>
 get_fe_by_name< 2 ,  3 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 2 ,  3 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 2 ,  3 > &,
 const Quadrature< 2 > &,
 const Quadrature< 2 > &,
 FullMatrix<double> &);
#endif

#if  2  ==  3 

 template class FEFactoryBase< 2 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 2 > &);

 template void
 compute_component_wise(const FiniteElement< 2 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 2 >(
 const FiniteElement< 2 > &,
 const FiniteElement< 2 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 2 , double>(
 const FiniteElement< 2 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 2 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  2 >> &,
 std::vector<Tensor<1,  2 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  2 >> &,
 std::vector<SymmetricTensor<2,  2 >> &);

# if  2  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 2 > &,
 const Quadrature< 2  - 1> &,
 const Quadrature< 2  - 1> &,
 const DoFHandler< 2 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 2 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 2 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(15))
namespace FETools
 {

#if  3  <=  1 
 template void
 get_interpolation_matrix< 3 ,
 double,
  1 >(
 const FiniteElement< 3 ,  1 > &,
 const FiniteElement< 3 ,  1 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 3 ,  1 >>
 get_fe_by_name< 3 ,  1 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 3 ,  1 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 3 ,  1 > &,
 const Quadrature< 3 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);
#endif

#if  3  ==  1 

 template class FEFactoryBase< 3 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 3 > &);

 template void
 compute_component_wise(const FiniteElement< 3 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 3 , double>(
 const FiniteElement< 3 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 3 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  3 >> &,
 std::vector<Tensor<1,  3 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  3 >> &,
 std::vector<SymmetricTensor<2,  3 >> &);

# if  3  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 3 > &,
 const Quadrature< 3  - 1> &,
 const Quadrature< 3  - 1> &,
 const DoFHandler< 3 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 3 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 3 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(16))
namespace FETools
 {

#if  3  <=  2 
 template void
 get_interpolation_matrix< 3 ,
 double,
  2 >(
 const FiniteElement< 3 ,  2 > &,
 const FiniteElement< 3 ,  2 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 3 ,  2 >>
 get_fe_by_name< 3 ,  2 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 3 ,  2 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 3 ,  2 > &,
 const Quadrature< 3 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);
#endif

#if  3  ==  2 

 template class FEFactoryBase< 3 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 3 > &);

 template void
 compute_component_wise(const FiniteElement< 3 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 3 , double>(
 const FiniteElement< 3 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 3 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  3 >> &,
 std::vector<Tensor<1,  3 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  3 >> &,
 std::vector<SymmetricTensor<2,  3 >> &);

# if  3  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 3 > &,
 const Quadrature< 3  - 1> &,
 const Quadrature< 3  - 1> &,
 const DoFHandler< 3 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 3 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 3 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(17))
namespace FETools
 {

#if  3  <=  3 
 template void
 get_interpolation_matrix< 3 ,
 double,
  3 >(
 const FiniteElement< 3 ,  3 > &,
 const FiniteElement< 3 ,  3 > &,
 FullMatrix<double> &);

 template std::unique_ptr<
 FiniteElement< 3 ,  3 >>
 get_fe_by_name< 3 ,  3 >(
 const std::string &);

 template void
 compute_interpolation_to_quadrature_points_matrix(
 const FiniteElement< 3 ,  3 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);

 template void
 compute_projection_from_quadrature_points_matrix(
 const FiniteElement< 3 ,  3 > &,
 const Quadrature< 3 > &,
 const Quadrature< 3 > &,
 FullMatrix<double> &);
#endif

#if  3  ==  3 

 template class FEFactoryBase< 3 >;

 template FullMatrix<double>
 compute_node_matrix(const FiniteElement< 3 > &);

 template void
 compute_component_wise(const FiniteElement< 3 > &,
 std::vector<unsigned int> &,
 std::vector<std::vector<unsigned int>> &);

 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_back_interpolation_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);
 template void
 get_interpolation_difference_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<double> &);
 template void
 get_projection_matrix< 3 >(
 const FiniteElement< 3 > &,
 const FiniteElement< 3 > &,
 FullMatrix<float> &);

 template void
 compute_face_embedding_matrices< 3 , double>(
 const FiniteElement< 3 > &,
 FullMatrix<double> (
 &)[GeometryInfo< 3 >::max_children_per_face],
 unsigned int,
 unsigned int,
 const double);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<Tensor<1,  3 >> &,
 std::vector<Tensor<1,  3 >> &);

 template void
 compute_projection_from_quadrature_points(
 const FullMatrix<double> &,
 const std::vector<SymmetricTensor<2,  3 >> &,
 std::vector<SymmetricTensor<2,  3 >> &);

# if  3  != 1
 template void
 compute_projection_from_face_quadrature_points_matrix(
 const FiniteElement< 3 > &,
 const Quadrature< 3  - 1> &,
 const Quadrature< 3  - 1> &,
 const DoFHandler< 3 >::active_cell_iterator &,
 unsigned int,
 FullMatrix<double> &);
# endif

 template std::vector<unsigned int>
 hierarchic_to_lexicographic_numbering< 3 >(unsigned int);

 template std::vector<unsigned int>
 lexicographic_to_hierarchic_numbering< 3 >(unsigned int);

#endif
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(18))
#if  1  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  1 ,
  double >(
 const FiniteElement< 1 ,  1 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(19))
#if  1  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  1 ,
  float >(
 const FiniteElement< 1 ,  1 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(20))
#if  1  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  2 ,
  double >(
 const FiniteElement< 1 ,  2 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(21))
#if  1  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  2 ,
  float >(
 const FiniteElement< 1 ,  2 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(22))
#if  1  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  3 ,
  double >(
 const FiniteElement< 1 ,  3 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(23))
#if  1  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  1 ,
  3 ,
  float >(
 const FiniteElement< 1 ,  3 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(24))
#if  2  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  1 ,
  double >(
 const FiniteElement< 2 ,  1 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(25))
#if  2  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  1 ,
  float >(
 const FiniteElement< 2 ,  1 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(26))
#if  2  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  2 ,
  double >(
 const FiniteElement< 2 ,  2 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(27))
#if  2  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  2 ,
  float >(
 const FiniteElement< 2 ,  2 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(28))
#if  2  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  3 ,
  double >(
 const FiniteElement< 2 ,  3 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(29))
#if  2  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  2 ,
  3 ,
  float >(
 const FiniteElement< 2 ,  3 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(30))
#if  3  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  1 ,
  double >(
 const FiniteElement< 3 ,  1 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(31))
#if  3  <=  1 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  1 ,
  float >(
 const FiniteElement< 3 ,  1 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(32))
#if  3  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  2 ,
  double >(
 const FiniteElement< 3 ,  2 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(33))
#if  3  <=  2 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  2 ,
  float >(
 const FiniteElement< 3 ,  2 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(34))
#if  3  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  3 ,
  double >(
 const FiniteElement< 3 ,  3 > &,
 const std::vector<Vector< double >> &,
 std::vector< double > &);

 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(35))
#if  3  <=  3 
 namespace FETools
 {

 template void
 convert_generalized_support_point_values_to_dof_values<
  3 ,
  3 ,
  float >(
 const FiniteElement< 3 ,  3 > &,
 const std::vector<Vector< float >> &,
 std::vector< float > &);

 }
#endif
 
#endif

#undef SPLIT_INSTANTIATIONS_CHECK
