// This file is automatically generated from corresponding .inst.in, do not edit.

#ifdef SPLIT_INSTANTIATIONS_COUNT
  #define SPLIT_INSTANTIATIONS_CHECK(C) (((C) % SPLIT_INSTANTIATIONS_COUNT) == SPLIT_INSTANTIATIONS_INDEX)
#else
  #define SPLIT_INSTANTIATIONS_CHECK(C) (1)
#endif

#if (SPLIT_INSTANTIATIONS_CHECK(0))
#if  1  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  Triangulation< 1 ,  1 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  1 > &,
 const  Triangulation< 1 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  Triangulation< 1 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  Triangulation< 1 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 1 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< Triangulation< 1 ,  1 > >(
 const  Triangulation< 1 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  Triangulation< 1 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(1))
#if  1  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  Triangulation< 1 ,  2 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  2 > &,
 const  Triangulation< 1 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  Triangulation< 1 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  Triangulation< 1 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 1 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< Triangulation< 1 ,  2 > >(
 const  Triangulation< 1 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  Triangulation< 1 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(2))
#if  1  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  Triangulation< 1 ,  3 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  3 > &,
 const  Triangulation< 1 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  Triangulation< 1 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  Triangulation< 1 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 1 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< Triangulation< 1 ,  3 > >(
 const  Triangulation< 1 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  Triangulation< 1 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(3))
#if  2  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  Triangulation< 2 ,  1 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  1 > &,
 const  Triangulation< 2 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  Triangulation< 2 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  Triangulation< 2 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 2 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< Triangulation< 2 ,  1 > >(
 const  Triangulation< 2 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  Triangulation< 2 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(4))
#if  2  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  Triangulation< 2 ,  2 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  2 > &,
 const  Triangulation< 2 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  Triangulation< 2 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  Triangulation< 2 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 2 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< Triangulation< 2 ,  2 > >(
 const  Triangulation< 2 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  Triangulation< 2 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(5))
#if  2  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  Triangulation< 2 ,  3 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  3 > &,
 const  Triangulation< 2 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  Triangulation< 2 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  Triangulation< 2 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 2 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< Triangulation< 2 ,  3 > >(
 const  Triangulation< 2 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  Triangulation< 2 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(6))
#if  3  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  Triangulation< 3 ,  1 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  1 > &,
 const  Triangulation< 3 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  Triangulation< 3 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  Triangulation< 3 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 3 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< Triangulation< 3 ,  1 > >(
 const  Triangulation< 3 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  Triangulation< 3 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(7))
#if  3  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  Triangulation< 3 ,  2 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  2 > &,
 const  Triangulation< 3 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  Triangulation< 3 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  Triangulation< 3 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 3 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< Triangulation< 3 ,  2 > >(
 const  Triangulation< 3 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  Triangulation< 3 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(8))
#if  3  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  Triangulation< 3 ,  3 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  3 > &,
 const  Triangulation< 3 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  Triangulation< 3 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  Triangulation< 3 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 3 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< Triangulation< 3 ,  3 > >(
 const  Triangulation< 3 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  Triangulation< 3 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(9))
#if  1  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::shared::Triangulation< 1 ,  1 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  1 > &,
 const  parallel::shared::Triangulation< 1 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::shared::Triangulation< 1 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::shared::Triangulation< 1 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 1 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 1 ,  1 > >(
 const  parallel::shared::Triangulation< 1 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::shared::Triangulation< 1 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(10))
#if  1  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::shared::Triangulation< 1 ,  2 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  2 > &,
 const  parallel::shared::Triangulation< 1 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::shared::Triangulation< 1 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::shared::Triangulation< 1 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 1 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 1 ,  2 > >(
 const  parallel::shared::Triangulation< 1 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::shared::Triangulation< 1 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(11))
#if  1  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::shared::Triangulation< 1 ,  3 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  3 > &,
 const  parallel::shared::Triangulation< 1 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::shared::Triangulation< 1 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::shared::Triangulation< 1 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 1 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 1 ,  3 > >(
 const  parallel::shared::Triangulation< 1 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::shared::Triangulation< 1 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(12))
#if  2  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::shared::Triangulation< 2 ,  1 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  1 > &,
 const  parallel::shared::Triangulation< 2 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::shared::Triangulation< 2 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::shared::Triangulation< 2 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 2 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 2 ,  1 > >(
 const  parallel::shared::Triangulation< 2 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::shared::Triangulation< 2 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(13))
#if  2  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::shared::Triangulation< 2 ,  2 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  2 > &,
 const  parallel::shared::Triangulation< 2 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::shared::Triangulation< 2 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::shared::Triangulation< 2 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 2 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 2 ,  2 > >(
 const  parallel::shared::Triangulation< 2 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::shared::Triangulation< 2 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(14))
#if  2  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::shared::Triangulation< 2 ,  3 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  3 > &,
 const  parallel::shared::Triangulation< 2 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::shared::Triangulation< 2 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::shared::Triangulation< 2 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 2 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 2 ,  3 > >(
 const  parallel::shared::Triangulation< 2 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::shared::Triangulation< 2 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(15))
#if  3  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::shared::Triangulation< 3 ,  1 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  1 > &,
 const  parallel::shared::Triangulation< 3 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::shared::Triangulation< 3 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::shared::Triangulation< 3 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 3 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 3 ,  1 > >(
 const  parallel::shared::Triangulation< 3 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::shared::Triangulation< 3 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(16))
#if  3  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::shared::Triangulation< 3 ,  2 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  2 > &,
 const  parallel::shared::Triangulation< 3 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::shared::Triangulation< 3 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::shared::Triangulation< 3 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 3 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 3 ,  2 > >(
 const  parallel::shared::Triangulation< 3 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::shared::Triangulation< 3 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(17))
#if  3  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::shared::Triangulation< 3 ,  3 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  3 > &,
 const  parallel::shared::Triangulation< 3 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::shared::Triangulation< 3 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::shared::Triangulation< 3 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 3 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::shared::Triangulation< 3 ,  3 > >(
 const  parallel::shared::Triangulation< 3 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::shared::Triangulation< 3 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(18))
#if  1  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::distributed::Triangulation< 1 ,  1 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  1 > &,
 const  parallel::distributed::Triangulation< 1 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::distributed::Triangulation< 1 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::distributed::Triangulation< 1 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 1 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 1 ,  1 > >(
 const  parallel::distributed::Triangulation< 1 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  1 ,
  parallel::distributed::Triangulation< 1 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(19))
#if  1  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::distributed::Triangulation< 1 ,  2 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  2 > &,
 const  parallel::distributed::Triangulation< 1 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::distributed::Triangulation< 1 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::distributed::Triangulation< 1 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 1 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 1 ,  2 > >(
 const  parallel::distributed::Triangulation< 1 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  2 ,
  parallel::distributed::Triangulation< 1 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(20))
#if  1  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::distributed::Triangulation< 1 ,  3 > >::type,
 Point< 1 >>
 find_active_cell_around_point(
 const Mapping< 1 ,  3 > &,
 const  parallel::distributed::Triangulation< 1 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::distributed::Triangulation< 1 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::distributed::Triangulation< 1 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 1 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 1 ,  3 > >(
 const  parallel::distributed::Triangulation< 1 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 1 ,
  3 ,
  parallel::distributed::Triangulation< 1 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(21))
#if  2  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::distributed::Triangulation< 2 ,  1 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  1 > &,
 const  parallel::distributed::Triangulation< 2 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::distributed::Triangulation< 2 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::distributed::Triangulation< 2 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 2 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 2 ,  1 > >(
 const  parallel::distributed::Triangulation< 2 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  1 ,
  parallel::distributed::Triangulation< 2 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(22))
#if  2  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::distributed::Triangulation< 2 ,  2 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  2 > &,
 const  parallel::distributed::Triangulation< 2 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::distributed::Triangulation< 2 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::distributed::Triangulation< 2 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 2 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 2 ,  2 > >(
 const  parallel::distributed::Triangulation< 2 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  2 ,
  parallel::distributed::Triangulation< 2 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(23))
#if  2  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::distributed::Triangulation< 2 ,  3 > >::type,
 Point< 2 >>
 find_active_cell_around_point(
 const Mapping< 2 ,  3 > &,
 const  parallel::distributed::Triangulation< 2 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::distributed::Triangulation< 2 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::distributed::Triangulation< 2 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 2 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 2 ,  3 > >(
 const  parallel::distributed::Triangulation< 2 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 2 ,
  3 ,
  parallel::distributed::Triangulation< 2 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(24))
#if  3  <=  1 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::distributed::Triangulation< 3 ,  1 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  1 > &,
 const  parallel::distributed::Triangulation< 3 ,  1 >  &,
 const Point< 1 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::distributed::Triangulation< 3 ,  1 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  1 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::distributed::Triangulation< 3 ,  1 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 1 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 1 >,
 typename Triangulation< 3 ,  1 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 1 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 3 ,  1 > >(
 const  parallel::distributed::Triangulation< 3 ,  1 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  1 ,
  parallel::distributed::Triangulation< 3 ,  1 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(25))
#if  3  <=  2 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::distributed::Triangulation< 3 ,  2 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  2 > &,
 const  parallel::distributed::Triangulation< 3 ,  2 >  &,
 const Point< 2 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::distributed::Triangulation< 3 ,  2 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  2 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::distributed::Triangulation< 3 ,  2 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 2 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 2 >,
 typename Triangulation< 3 ,  2 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 2 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 3 ,  2 > >(
 const  parallel::distributed::Triangulation< 3 ,  2 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  2 ,
  parallel::distributed::Triangulation< 3 ,  2 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(26))
#if  3  <=  3 
 namespace GridTools
 {
 template std::pair<
 dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::distributed::Triangulation< 3 ,  3 > >::type,
 Point< 3 >>
 find_active_cell_around_point(
 const Mapping< 3 ,  3 > &,
 const  parallel::distributed::Triangulation< 3 ,  3 >  &,
 const Point< 3 > &,
 const std::vector<std::set<
 typename dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::distributed::Triangulation< 3 ,  3 > >::type>> &,
 const std::vector<std::vector<Tensor<1,  3 >>> &,
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::distributed::Triangulation< 3 ,  3 > >::type &,
 const std::vector<bool> &,
 const RTree<std::pair<Point< 3 >, unsigned int>> &,
 const double,
 const RTree<std::pair<
 BoundingBox< 3 >,
 typename Triangulation< 3 ,  3 >::
 active_cell_iterator>> *);

 template std::vector<BoundingBox< 3 >>
 compute_mesh_predicate_bounding_box< parallel::distributed::Triangulation< 3 ,  3 > >(
 const  parallel::distributed::Triangulation< 3 ,  3 >  &,
 const std::function<bool(
 const dealii::internal::ActiveCellIterator< 3 ,
  3 ,
  parallel::distributed::Triangulation< 3 ,  3 > >::type &)> &,
 const unsigned int,
 const bool,
 const unsigned int);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(27))
#if  1  <=  1 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 1 ,  1 >(
 const typename Triangulation<
  1 ,
  1 >::active_cell_iterator &,
 const Point< 1 > &,
 const Mapping< 1 ,  1 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 1 ,
  1 >
 &triangulation);

 template std::map<unsigned int, Point< 1 >>
 extract_used_vertices(
 const Triangulation< 1 ,  1 > &mesh,
 const Mapping< 1 ,  1 > &mapping);

 template std::pair<
 typename Triangulation< 1 ,
  1 >::active_cell_iterator,
 Point< 1 >>
 find_active_cell_around_point(
 const Cache< 1 ,  1 > &,
 const Point< 1 > &,
 const typename Triangulation<
  1 ,
  1 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 1 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  1 ,
  1 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 1 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  1 ,
  1 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  1 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 1 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  1 ,
  1 >
 internal::distributed_compute_point_locations(
 const Cache< 1 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(28))
#if  1  <=  2 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 1 ,  2 >(
 const typename Triangulation<
  1 ,
  2 >::active_cell_iterator &,
 const Point< 2 > &,
 const Mapping< 1 ,  2 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 1 ,
  2 >
 &triangulation);

 template std::map<unsigned int, Point< 2 >>
 extract_used_vertices(
 const Triangulation< 1 ,  2 > &mesh,
 const Mapping< 1 ,  2 > &mapping);

 template std::pair<
 typename Triangulation< 1 ,
  2 >::active_cell_iterator,
 Point< 1 >>
 find_active_cell_around_point(
 const Cache< 1 ,  2 > &,
 const Point< 2 > &,
 const typename Triangulation<
  1 ,
  2 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 1 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  1 ,
  2 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 1 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  1 ,
  2 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  1 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 1 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  1 ,
  2 >
 internal::distributed_compute_point_locations(
 const Cache< 1 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(29))
#if  1  <=  3 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 1 ,  3 >(
 const typename Triangulation<
  1 ,
  3 >::active_cell_iterator &,
 const Point< 3 > &,
 const Mapping< 1 ,  3 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 1 ,
  3 >
 &triangulation);

 template std::map<unsigned int, Point< 3 >>
 extract_used_vertices(
 const Triangulation< 1 ,  3 > &mesh,
 const Mapping< 1 ,  3 > &mapping);

 template std::pair<
 typename Triangulation< 1 ,
  3 >::active_cell_iterator,
 Point< 1 >>
 find_active_cell_around_point(
 const Cache< 1 ,  3 > &,
 const Point< 3 > &,
 const typename Triangulation<
  1 ,
  3 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 1 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  1 ,
  3 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  1 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 1 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  1 ,
  3 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  1 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 1 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  1 ,
  3 >
 internal::distributed_compute_point_locations(
 const Cache< 1 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(30))
#if  2  <=  1 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 2 ,  1 >(
 const typename Triangulation<
  2 ,
  1 >::active_cell_iterator &,
 const Point< 1 > &,
 const Mapping< 2 ,  1 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 2 ,
  1 >
 &triangulation);

 template std::map<unsigned int, Point< 1 >>
 extract_used_vertices(
 const Triangulation< 2 ,  1 > &mesh,
 const Mapping< 2 ,  1 > &mapping);

 template std::pair<
 typename Triangulation< 2 ,
  1 >::active_cell_iterator,
 Point< 2 >>
 find_active_cell_around_point(
 const Cache< 2 ,  1 > &,
 const Point< 1 > &,
 const typename Triangulation<
  2 ,
  1 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 2 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  2 ,
  1 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 2 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  2 ,
  1 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  2 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 2 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  2 ,
  1 >
 internal::distributed_compute_point_locations(
 const Cache< 2 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(31))
#if  2  <=  2 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 2 ,  2 >(
 const typename Triangulation<
  2 ,
  2 >::active_cell_iterator &,
 const Point< 2 > &,
 const Mapping< 2 ,  2 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 2 ,
  2 >
 &triangulation);

 template std::map<unsigned int, Point< 2 >>
 extract_used_vertices(
 const Triangulation< 2 ,  2 > &mesh,
 const Mapping< 2 ,  2 > &mapping);

 template std::pair<
 typename Triangulation< 2 ,
  2 >::active_cell_iterator,
 Point< 2 >>
 find_active_cell_around_point(
 const Cache< 2 ,  2 > &,
 const Point< 2 > &,
 const typename Triangulation<
  2 ,
  2 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 2 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  2 ,
  2 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 2 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  2 ,
  2 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  2 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 2 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  2 ,
  2 >
 internal::distributed_compute_point_locations(
 const Cache< 2 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(32))
#if  2  <=  3 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 2 ,  3 >(
 const typename Triangulation<
  2 ,
  3 >::active_cell_iterator &,
 const Point< 3 > &,
 const Mapping< 2 ,  3 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 2 ,
  3 >
 &triangulation);

 template std::map<unsigned int, Point< 3 >>
 extract_used_vertices(
 const Triangulation< 2 ,  3 > &mesh,
 const Mapping< 2 ,  3 > &mapping);

 template std::pair<
 typename Triangulation< 2 ,
  3 >::active_cell_iterator,
 Point< 2 >>
 find_active_cell_around_point(
 const Cache< 2 ,  3 > &,
 const Point< 3 > &,
 const typename Triangulation<
  2 ,
  3 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 2 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  2 ,
  3 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  2 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 2 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  2 ,
  3 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  2 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 2 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  2 ,
  3 >
 internal::distributed_compute_point_locations(
 const Cache< 2 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(33))
#if  3  <=  1 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 3 ,  1 >(
 const typename Triangulation<
  3 ,
  1 >::active_cell_iterator &,
 const Point< 1 > &,
 const Mapping< 3 ,  1 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 3 ,
  1 >
 &triangulation);

 template std::map<unsigned int, Point< 1 >>
 extract_used_vertices(
 const Triangulation< 3 ,  1 > &mesh,
 const Mapping< 3 ,  1 > &mapping);

 template std::pair<
 typename Triangulation< 3 ,
  1 >::active_cell_iterator,
 Point< 3 >>
 find_active_cell_around_point(
 const Cache< 3 ,  1 > &,
 const Point< 1 > &,
 const typename Triangulation<
  3 ,
  1 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 3 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  3 ,
  1 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 3 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const typename Triangulation<
  3 ,
  1 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  3 ,
  1 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 1 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 3 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  3 ,
  1 >
 internal::distributed_compute_point_locations(
 const Cache< 3 ,  1 > &,
 const std::vector<Point< 1 >> &,
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(34))
#if  3  <=  2 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 3 ,  2 >(
 const typename Triangulation<
  3 ,
  2 >::active_cell_iterator &,
 const Point< 2 > &,
 const Mapping< 3 ,  2 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 3 ,
  2 >
 &triangulation);

 template std::map<unsigned int, Point< 2 >>
 extract_used_vertices(
 const Triangulation< 3 ,  2 > &mesh,
 const Mapping< 3 ,  2 > &mapping);

 template std::pair<
 typename Triangulation< 3 ,
  2 >::active_cell_iterator,
 Point< 3 >>
 find_active_cell_around_point(
 const Cache< 3 ,  2 > &,
 const Point< 2 > &,
 const typename Triangulation<
  3 ,
  2 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 3 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  3 ,
  2 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 3 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const typename Triangulation<
  3 ,
  2 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  3 ,
  2 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 2 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 3 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  3 ,
  2 >
 internal::distributed_compute_point_locations(
 const Cache< 3 ,  2 > &,
 const std::vector<Point< 2 >> &,
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(35))
#if  3  <=  3 
 namespace GridTools
 {

 template unsigned int
 find_closest_vertex_of_cell< 3 ,  3 >(
 const typename Triangulation<
  3 ,
  3 >::active_cell_iterator &,
 const Point< 3 > &,
 const Mapping< 3 ,  3 > &);

 template std::map<unsigned int, types::global_vertex_index>
 compute_local_to_global_vertex_index_map(
 const parallel::distributed::Triangulation< 3 ,
  3 >
 &triangulation);

 template std::map<unsigned int, Point< 3 >>
 extract_used_vertices(
 const Triangulation< 3 ,  3 > &mesh,
 const Mapping< 3 ,  3 > &mapping);

 template std::pair<
 typename Triangulation< 3 ,
  3 >::active_cell_iterator,
 Point< 3 >>
 find_active_cell_around_point(
 const Cache< 3 ,  3 > &,
 const Point< 3 > &,
 const typename Triangulation<
  3 ,
  3 >::active_cell_iterator &,
 const std::vector<bool> &,
 const double);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<unsigned int>>
 compute_point_locations_try_all(
 const Cache< 3 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  3 ,
  3 >::active_cell_iterator &);

 template std::tuple<std::vector<typename Triangulation<
  3 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 compute_point_locations(
 const Cache< 3 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const typename Triangulation<
  3 ,
  3 >::active_cell_iterator &);

 template std::tuple<
 std::vector<typename Triangulation<
  3 ,
  3 >::active_cell_iterator>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>,
 std::vector<std::vector<Point< 3 >>>,
 std::vector<std::vector<unsigned int>>>
 distributed_compute_point_locations(
 const Cache< 3 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const double tolerance);

 template internal::DistributedComputePointLocationsInternal<
  3 ,
  3 >
 internal::distributed_compute_point_locations(
 const Cache< 3 ,  3 > &,
 const std::vector<Point< 3 >> &,
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const std::vector<bool> &marked_vertices,
 const double,
 const bool,
 const bool);
 }

#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(36))
dealii::internal::ActiveCellIterator<
  1 ,
  1 ,
 parallel::distributed::Triangulation< 1 ,
  1 >>::type
 find_active_cell_around_point(
 const parallel::distributed::Triangulation< 1 > &,
 const Point< 1 > &p);

 template unsigned int GridTools::find_closest_vertex(
 const std::map<unsigned int, Point< 1 >> &vertices,
 const Point< 1 > & p);

 template std::vector<std::vector<BoundingBox< 1 >>>
 GridTools::exchange_local_bounding_boxes(
 const std::vector<BoundingBox< 1 >> &,
 const MPI_Comm &);

 template std::tuple<std::vector<std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const std::vector<std::vector<BoundingBox< 1 >>> &,
 const std::vector<Point< 1 >> &);

 template std::tuple<std::map<unsigned int, std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const RTree<std::pair<BoundingBox< 1 >, unsigned int>>
 &,
 const std::vector<Point< 1 >> &);

 template RTree<
 std::pair<BoundingBox< 1 >, unsigned int>>
 GridTools::build_global_description_tree(
 const std::vector<BoundingBox< 1 >> &,
 const MPI_Comm &);

 template Vector<double> GridTools::compute_aspect_ratio_of_cells(
 const Mapping< 1 > &,
 const Triangulation< 1 > &,
 const Quadrature< 1 > &);

 template double GridTools::compute_maximum_aspect_ratio(
 const Mapping< 1 > &,
 const Triangulation< 1 > &,
 const Quadrature< 1 > &);
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(37))
dealii::internal::ActiveCellIterator<
  2 ,
  2 ,
 parallel::distributed::Triangulation< 2 ,
  2 >>::type
 find_active_cell_around_point(
 const parallel::distributed::Triangulation< 2 > &,
 const Point< 2 > &p);

 template unsigned int GridTools::find_closest_vertex(
 const std::map<unsigned int, Point< 2 >> &vertices,
 const Point< 2 > & p);

 template std::vector<std::vector<BoundingBox< 2 >>>
 GridTools::exchange_local_bounding_boxes(
 const std::vector<BoundingBox< 2 >> &,
 const MPI_Comm &);

 template std::tuple<std::vector<std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const std::vector<std::vector<BoundingBox< 2 >>> &,
 const std::vector<Point< 2 >> &);

 template std::tuple<std::map<unsigned int, std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const RTree<std::pair<BoundingBox< 2 >, unsigned int>>
 &,
 const std::vector<Point< 2 >> &);

 template RTree<
 std::pair<BoundingBox< 2 >, unsigned int>>
 GridTools::build_global_description_tree(
 const std::vector<BoundingBox< 2 >> &,
 const MPI_Comm &);

 template Vector<double> GridTools::compute_aspect_ratio_of_cells(
 const Mapping< 2 > &,
 const Triangulation< 2 > &,
 const Quadrature< 2 > &);

 template double GridTools::compute_maximum_aspect_ratio(
 const Mapping< 2 > &,
 const Triangulation< 2 > &,
 const Quadrature< 2 > &);
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(38))
dealii::internal::ActiveCellIterator<
  3 ,
  3 ,
 parallel::distributed::Triangulation< 3 ,
  3 >>::type
 find_active_cell_around_point(
 const parallel::distributed::Triangulation< 3 > &,
 const Point< 3 > &p);

 template unsigned int GridTools::find_closest_vertex(
 const std::map<unsigned int, Point< 3 >> &vertices,
 const Point< 3 > & p);

 template std::vector<std::vector<BoundingBox< 3 >>>
 GridTools::exchange_local_bounding_boxes(
 const std::vector<BoundingBox< 3 >> &,
 const MPI_Comm &);

 template std::tuple<std::vector<std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const std::vector<std::vector<BoundingBox< 3 >>> &,
 const std::vector<Point< 3 >> &);

 template std::tuple<std::map<unsigned int, std::vector<unsigned int>>,
 std::map<unsigned int, unsigned int>,
 std::map<unsigned int, std::vector<unsigned int>>>
 GridTools::guess_point_owner(
 const RTree<std::pair<BoundingBox< 3 >, unsigned int>>
 &,
 const std::vector<Point< 3 >> &);

 template RTree<
 std::pair<BoundingBox< 3 >, unsigned int>>
 GridTools::build_global_description_tree(
 const std::vector<BoundingBox< 3 >> &,
 const MPI_Comm &);

 template Vector<double> GridTools::compute_aspect_ratio_of_cells(
 const Mapping< 3 > &,
 const Triangulation< 3 > &,
 const Quadrature< 3 > &);

 template double GridTools::compute_maximum_aspect_ratio(
 const Mapping< 3 > &,
 const Triangulation< 3 > &,
 const Quadrature< 3 > &);
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(39))
#if  1  <=  1 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 1 ,  1 > &);

 template double
 volume(const Triangulation< 1 ,  1 > &,
 const Mapping< 1 ,  1 > &);

 template std::pair<
 DerivativeForm<1,  1 ,  1 >,
 Tensor<1,  1 >>
 affine_cell_approximation< 1 ,  1 >(
 const ArrayView<const Point< 1 >> &);

 template BoundingBox< 1 >
 compute_bounding_box(
 const Triangulation< 1 ,  1 > &);

 template std::tuple<std::vector<Point< 1 >>,
 std::vector<CellData< 1 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 1 ,  1 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 1 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 1 >> &);

# if  1  ==  1 
 template void
 consistently_order_cells(std::vector<CellData< 1 >> &);
# endif

 template void
 shift< 1 >(
 const Tensor<1,  1 > &,
 Triangulation< 1 ,  1 > &);

 template void
 scale< 1 >(
 const double,
 Triangulation< 1 ,  1 > &);

# if  1  == 3
 template void
 rotate< 1 >(
 const Tensor<1,  1 , double> &,
 const double,
 Triangulation< 1 ,  1 > &);

 template void
 rotate< 1 >(
 const double,
 const unsigned int,
 Triangulation< 1 ,  1 > &);
# endif

 template void
 distort_random< 1 >(
 const double,
 Triangulation< 1 ,  1 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 1 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 1 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 1 ,  1 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 1 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 1 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 1 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 1 ,  1 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 1 ,  1 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 1 ,  1 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 1 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 1 ,  1 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 1 ,  1 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 1 ,  1 >
 &triangulation,
 const Mapping< 1 ,  1 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 1 ,  1 >
 &triangulation,
 const Mapping< 1 ,  1 > &);

 template std::map<unsigned int, Point< 1 >>
 get_all_vertices_at_boundary(
 const Triangulation< 1 ,  1 > &tria);

 template std::vector<
 std::set<Triangulation< 1 ,
  1 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 1 ,  1 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  1 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 1 ,  1 > &mesh,
 const std::vector<std::set<typename Triangulation<
  1 ,
  1 >::active_cell_iterator>> &vertex_to_cells);

# if  1  ==  1 
# if  1  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 1 >> &new_points,
 Triangulation< 1 > & triangulation,
 const Function< 1 > * coefficient,
 const bool);

 template Triangulation< 1 ,
  1 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 1 ,
  1 >::DistortedCellList
 &distorted_cells,
 Triangulation< 1 ,  1 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(40))
#if  1  <=  2 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 1 ,  2 > &);

 template double
 volume(const Triangulation< 1 ,  2 > &,
 const Mapping< 1 ,  2 > &);

 template std::pair<
 DerivativeForm<1,  1 ,  2 >,
 Tensor<1,  2 >>
 affine_cell_approximation< 1 ,  2 >(
 const ArrayView<const Point< 2 >> &);

 template BoundingBox< 2 >
 compute_bounding_box(
 const Triangulation< 1 ,  2 > &);

 template std::tuple<std::vector<Point< 2 >>,
 std::vector<CellData< 1 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 1 ,  2 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 1 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 1 >> &);

# if  1  ==  2 
 template void
 consistently_order_cells(std::vector<CellData< 1 >> &);
# endif

 template void
 shift< 1 >(
 const Tensor<1,  2 > &,
 Triangulation< 1 ,  2 > &);

 template void
 scale< 1 >(
 const double,
 Triangulation< 1 ,  2 > &);

# if  2  == 3
 template void
 rotate< 1 >(
 const Tensor<1,  2 , double> &,
 const double,
 Triangulation< 1 ,  2 > &);

 template void
 rotate< 1 >(
 const double,
 const unsigned int,
 Triangulation< 1 ,  2 > &);
# endif

 template void
 distort_random< 1 >(
 const double,
 Triangulation< 1 ,  2 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 1 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 1 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 1 ,  2 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 1 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 1 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 1 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 1 ,  2 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 1 ,  2 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 1 ,  2 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 1 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 1 ,  2 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 1 ,  2 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 1 ,  2 >
 &triangulation,
 const Mapping< 1 ,  2 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 1 ,  2 >
 &triangulation,
 const Mapping< 1 ,  2 > &);

 template std::map<unsigned int, Point< 2 >>
 get_all_vertices_at_boundary(
 const Triangulation< 1 ,  2 > &tria);

 template std::vector<
 std::set<Triangulation< 1 ,
  2 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 1 ,  2 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  2 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 1 ,  2 > &mesh,
 const std::vector<std::set<typename Triangulation<
  1 ,
  2 >::active_cell_iterator>> &vertex_to_cells);

# if  1  ==  2 
# if  1  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 1 >> &new_points,
 Triangulation< 1 > & triangulation,
 const Function< 1 > * coefficient,
 const bool);

 template Triangulation< 1 ,
  2 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 1 ,
  2 >::DistortedCellList
 &distorted_cells,
 Triangulation< 1 ,  2 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(41))
#if  1  <=  3 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 1 ,  3 > &);

 template double
 volume(const Triangulation< 1 ,  3 > &,
 const Mapping< 1 ,  3 > &);

 template std::pair<
 DerivativeForm<1,  1 ,  3 >,
 Tensor<1,  3 >>
 affine_cell_approximation< 1 ,  3 >(
 const ArrayView<const Point< 3 >> &);

 template BoundingBox< 3 >
 compute_bounding_box(
 const Triangulation< 1 ,  3 > &);

 template std::tuple<std::vector<Point< 3 >>,
 std::vector<CellData< 1 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 1 ,  3 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 1 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 1 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 1 >> &);

# if  1  ==  3 
 template void
 consistently_order_cells(std::vector<CellData< 1 >> &);
# endif

 template void
 shift< 1 >(
 const Tensor<1,  3 > &,
 Triangulation< 1 ,  3 > &);

 template void
 scale< 1 >(
 const double,
 Triangulation< 1 ,  3 > &);

# if  3  == 3
 template void
 rotate< 1 >(
 const Tensor<1,  3 , double> &,
 const double,
 Triangulation< 1 ,  3 > &);

 template void
 rotate< 1 >(
 const double,
 const unsigned int,
 Triangulation< 1 ,  3 > &);
# endif

 template void
 distort_random< 1 >(
 const double,
 Triangulation< 1 ,  3 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 1 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 1 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 1 ,  3 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 1 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 1 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 1 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 1 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 1 ,  3 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 1 ,  3 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 1 ,  3 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 1 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 1 ,  3 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 1 ,  3 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 1 ,  3 >
 &triangulation,
 const Mapping< 1 ,  3 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 1 ,  3 >
 &triangulation,
 const Mapping< 1 ,  3 > &);

 template std::map<unsigned int, Point< 3 >>
 get_all_vertices_at_boundary(
 const Triangulation< 1 ,  3 > &tria);

 template std::vector<
 std::set<Triangulation< 1 ,
  3 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 1 ,  3 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  3 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 1 ,  3 > &mesh,
 const std::vector<std::set<typename Triangulation<
  1 ,
  3 >::active_cell_iterator>> &vertex_to_cells);

# if  1  ==  3 
# if  1  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 1 >> &new_points,
 Triangulation< 1 > & triangulation,
 const Function< 1 > * coefficient,
 const bool);

 template Triangulation< 1 ,
  3 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 1 ,
  3 >::DistortedCellList
 &distorted_cells,
 Triangulation< 1 ,  3 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(42))
#if  2  <=  1 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 2 ,  1 > &);

 template double
 volume(const Triangulation< 2 ,  1 > &,
 const Mapping< 2 ,  1 > &);

 template std::pair<
 DerivativeForm<1,  2 ,  1 >,
 Tensor<1,  1 >>
 affine_cell_approximation< 2 ,  1 >(
 const ArrayView<const Point< 1 >> &);

 template BoundingBox< 1 >
 compute_bounding_box(
 const Triangulation< 2 ,  1 > &);

 template std::tuple<std::vector<Point< 1 >>,
 std::vector<CellData< 2 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 2 ,  1 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 2 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 2 >> &);

# if  2  ==  1 
 template void
 consistently_order_cells(std::vector<CellData< 2 >> &);
# endif

 template void
 shift< 2 >(
 const Tensor<1,  1 > &,
 Triangulation< 2 ,  1 > &);

 template void
 scale< 2 >(
 const double,
 Triangulation< 2 ,  1 > &);

# if  1  == 3
 template void
 rotate< 2 >(
 const Tensor<1,  1 , double> &,
 const double,
 Triangulation< 2 ,  1 > &);

 template void
 rotate< 2 >(
 const double,
 const unsigned int,
 Triangulation< 2 ,  1 > &);
# endif

 template void
 distort_random< 2 >(
 const double,
 Triangulation< 2 ,  1 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 2 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 2 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 2 ,  1 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 2 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 2 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 2 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 2 ,  1 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 2 ,  1 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 2 ,  1 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 2 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 2 ,  1 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 2 ,  1 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 2 ,  1 >
 &triangulation,
 const Mapping< 2 ,  1 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 2 ,  1 >
 &triangulation,
 const Mapping< 2 ,  1 > &);

 template std::map<unsigned int, Point< 1 >>
 get_all_vertices_at_boundary(
 const Triangulation< 2 ,  1 > &tria);

 template std::vector<
 std::set<Triangulation< 2 ,
  1 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 2 ,  1 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  1 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 2 ,  1 > &mesh,
 const std::vector<std::set<typename Triangulation<
  2 ,
  1 >::active_cell_iterator>> &vertex_to_cells);

# if  2  ==  1 
# if  2  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 2 >> &new_points,
 Triangulation< 2 > & triangulation,
 const Function< 2 > * coefficient,
 const bool);

 template Triangulation< 2 ,
  1 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 2 ,
  1 >::DistortedCellList
 &distorted_cells,
 Triangulation< 2 ,  1 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(43))
#if  2  <=  2 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 2 ,  2 > &);

 template double
 volume(const Triangulation< 2 ,  2 > &,
 const Mapping< 2 ,  2 > &);

 template std::pair<
 DerivativeForm<1,  2 ,  2 >,
 Tensor<1,  2 >>
 affine_cell_approximation< 2 ,  2 >(
 const ArrayView<const Point< 2 >> &);

 template BoundingBox< 2 >
 compute_bounding_box(
 const Triangulation< 2 ,  2 > &);

 template std::tuple<std::vector<Point< 2 >>,
 std::vector<CellData< 2 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 2 ,  2 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 2 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 2 >> &);

# if  2  ==  2 
 template void
 consistently_order_cells(std::vector<CellData< 2 >> &);
# endif

 template void
 shift< 2 >(
 const Tensor<1,  2 > &,
 Triangulation< 2 ,  2 > &);

 template void
 scale< 2 >(
 const double,
 Triangulation< 2 ,  2 > &);

# if  2  == 3
 template void
 rotate< 2 >(
 const Tensor<1,  2 , double> &,
 const double,
 Triangulation< 2 ,  2 > &);

 template void
 rotate< 2 >(
 const double,
 const unsigned int,
 Triangulation< 2 ,  2 > &);
# endif

 template void
 distort_random< 2 >(
 const double,
 Triangulation< 2 ,  2 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 2 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 2 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 2 ,  2 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 2 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 2 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 2 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 2 ,  2 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 2 ,  2 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 2 ,  2 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 2 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 2 ,  2 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 2 ,  2 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 2 ,  2 >
 &triangulation,
 const Mapping< 2 ,  2 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 2 ,  2 >
 &triangulation,
 const Mapping< 2 ,  2 > &);

 template std::map<unsigned int, Point< 2 >>
 get_all_vertices_at_boundary(
 const Triangulation< 2 ,  2 > &tria);

 template std::vector<
 std::set<Triangulation< 2 ,
  2 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 2 ,  2 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  2 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 2 ,  2 > &mesh,
 const std::vector<std::set<typename Triangulation<
  2 ,
  2 >::active_cell_iterator>> &vertex_to_cells);

# if  2  ==  2 
# if  2  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 2 >> &new_points,
 Triangulation< 2 > & triangulation,
 const Function< 2 > * coefficient,
 const bool);

 template Triangulation< 2 ,
  2 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 2 ,
  2 >::DistortedCellList
 &distorted_cells,
 Triangulation< 2 ,  2 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(44))
#if  2  <=  3 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 2 ,  3 > &);

 template double
 volume(const Triangulation< 2 ,  3 > &,
 const Mapping< 2 ,  3 > &);

 template std::pair<
 DerivativeForm<1,  2 ,  3 >,
 Tensor<1,  3 >>
 affine_cell_approximation< 2 ,  3 >(
 const ArrayView<const Point< 3 >> &);

 template BoundingBox< 3 >
 compute_bounding_box(
 const Triangulation< 2 ,  3 > &);

 template std::tuple<std::vector<Point< 3 >>,
 std::vector<CellData< 2 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 2 ,  3 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 2 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 2 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 2 >> &);

# if  2  ==  3 
 template void
 consistently_order_cells(std::vector<CellData< 2 >> &);
# endif

 template void
 shift< 2 >(
 const Tensor<1,  3 > &,
 Triangulation< 2 ,  3 > &);

 template void
 scale< 2 >(
 const double,
 Triangulation< 2 ,  3 > &);

# if  3  == 3
 template void
 rotate< 2 >(
 const Tensor<1,  3 , double> &,
 const double,
 Triangulation< 2 ,  3 > &);

 template void
 rotate< 2 >(
 const double,
 const unsigned int,
 Triangulation< 2 ,  3 > &);
# endif

 template void
 distort_random< 2 >(
 const double,
 Triangulation< 2 ,  3 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 2 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 2 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 2 ,  3 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 2 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 2 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 2 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 2 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 2 ,  3 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 2 ,  3 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 2 ,  3 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 2 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 2 ,  3 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 2 ,  3 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 2 ,  3 >
 &triangulation,
 const Mapping< 2 ,  3 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 2 ,  3 >
 &triangulation,
 const Mapping< 2 ,  3 > &);

 template std::map<unsigned int, Point< 3 >>
 get_all_vertices_at_boundary(
 const Triangulation< 2 ,  3 > &tria);

 template std::vector<
 std::set<Triangulation< 2 ,
  3 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 2 ,  3 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  3 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 2 ,  3 > &mesh,
 const std::vector<std::set<typename Triangulation<
  2 ,
  3 >::active_cell_iterator>> &vertex_to_cells);

# if  2  ==  3 
# if  2  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 2 >> &new_points,
 Triangulation< 2 > & triangulation,
 const Function< 2 > * coefficient,
 const bool);

 template Triangulation< 2 ,
  3 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 2 ,
  3 >::DistortedCellList
 &distorted_cells,
 Triangulation< 2 ,  3 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(45))
#if  3  <=  1 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 3 ,  1 > &);

 template double
 volume(const Triangulation< 3 ,  1 > &,
 const Mapping< 3 ,  1 > &);

 template std::pair<
 DerivativeForm<1,  3 ,  1 >,
 Tensor<1,  1 >>
 affine_cell_approximation< 3 ,  1 >(
 const ArrayView<const Point< 1 >> &);

 template BoundingBox< 1 >
 compute_bounding_box(
 const Triangulation< 3 ,  1 > &);

 template std::tuple<std::vector<Point< 1 >>,
 std::vector<CellData< 3 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 3 ,  1 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 1 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 3 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 1 >> &,
 std::vector<CellData< 3 >> &);

# if  3  ==  1 
 template void
 consistently_order_cells(std::vector<CellData< 3 >> &);
# endif

 template void
 shift< 3 >(
 const Tensor<1,  1 > &,
 Triangulation< 3 ,  1 > &);

 template void
 scale< 3 >(
 const double,
 Triangulation< 3 ,  1 > &);

# if  1  == 3
 template void
 rotate< 3 >(
 const Tensor<1,  1 , double> &,
 const double,
 Triangulation< 3 ,  1 > &);

 template void
 rotate< 3 >(
 const double,
 const unsigned int,
 Triangulation< 3 ,  1 > &);
# endif

 template void
 distort_random< 3 >(
 const double,
 Triangulation< 3 ,  1 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 3 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 3 ,  1 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 3 ,  1 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 3 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 3 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 3 ,  1 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 3 ,  1 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 3 ,  1 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 3 ,  1 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 3 ,  1 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 3 ,  1 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 3 ,  1 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 3 ,  1 >
 &triangulation,
 const Mapping< 3 ,  1 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 3 ,  1 >
 &triangulation,
 const Mapping< 3 ,  1 > &);

 template std::map<unsigned int, Point< 1 >>
 get_all_vertices_at_boundary(
 const Triangulation< 3 ,  1 > &tria);

 template std::vector<
 std::set<Triangulation< 3 ,
  1 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 3 ,  1 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  1 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 3 ,  1 > &mesh,
 const std::vector<std::set<typename Triangulation<
  3 ,
  1 >::active_cell_iterator>> &vertex_to_cells);

# if  3  ==  1 
# if  3  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 3 >> &new_points,
 Triangulation< 3 > & triangulation,
 const Function< 3 > * coefficient,
 const bool);

 template Triangulation< 3 ,
  1 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 3 ,
  1 >::DistortedCellList
 &distorted_cells,
 Triangulation< 3 ,  1 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(46))
#if  3  <=  2 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 3 ,  2 > &);

 template double
 volume(const Triangulation< 3 ,  2 > &,
 const Mapping< 3 ,  2 > &);

 template std::pair<
 DerivativeForm<1,  3 ,  2 >,
 Tensor<1,  2 >>
 affine_cell_approximation< 3 ,  2 >(
 const ArrayView<const Point< 2 >> &);

 template BoundingBox< 2 >
 compute_bounding_box(
 const Triangulation< 3 ,  2 > &);

 template std::tuple<std::vector<Point< 2 >>,
 std::vector<CellData< 3 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 3 ,  2 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 2 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 3 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 2 >> &,
 std::vector<CellData< 3 >> &);

# if  3  ==  2 
 template void
 consistently_order_cells(std::vector<CellData< 3 >> &);
# endif

 template void
 shift< 3 >(
 const Tensor<1,  2 > &,
 Triangulation< 3 ,  2 > &);

 template void
 scale< 3 >(
 const double,
 Triangulation< 3 ,  2 > &);

# if  2  == 3
 template void
 rotate< 3 >(
 const Tensor<1,  2 , double> &,
 const double,
 Triangulation< 3 ,  2 > &);

 template void
 rotate< 3 >(
 const double,
 const unsigned int,
 Triangulation< 3 ,  2 > &);
# endif

 template void
 distort_random< 3 >(
 const double,
 Triangulation< 3 ,  2 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 3 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 3 ,  2 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 3 ,  2 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 3 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 3 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 3 ,  2 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 3 ,  2 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 3 ,  2 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 3 ,  2 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 3 ,  2 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 3 ,  2 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 3 ,  2 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 3 ,  2 >
 &triangulation,
 const Mapping< 3 ,  2 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 3 ,  2 >
 &triangulation,
 const Mapping< 3 ,  2 > &);

 template std::map<unsigned int, Point< 2 >>
 get_all_vertices_at_boundary(
 const Triangulation< 3 ,  2 > &tria);

 template std::vector<
 std::set<Triangulation< 3 ,
  2 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 3 ,  2 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  2 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 3 ,  2 > &mesh,
 const std::vector<std::set<typename Triangulation<
  3 ,
  2 >::active_cell_iterator>> &vertex_to_cells);

# if  3  ==  2 
# if  3  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 3 >> &new_points,
 Triangulation< 3 > & triangulation,
 const Function< 3 > * coefficient,
 const bool);

 template Triangulation< 3 ,
  2 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 3 ,
  2 >::DistortedCellList
 &distorted_cells,
 Triangulation< 3 ,  2 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(47))
#if  3  <=  3 
 namespace GridTools
 {
 template double
 diameter(
 const Triangulation< 3 ,  3 > &);

 template double
 volume(const Triangulation< 3 ,  3 > &,
 const Mapping< 3 ,  3 > &);

 template std::pair<
 DerivativeForm<1,  3 ,  3 >,
 Tensor<1,  3 >>
 affine_cell_approximation< 3 ,  3 >(
 const ArrayView<const Point< 3 >> &);

 template BoundingBox< 3 >
 compute_bounding_box(
 const Triangulation< 3 ,  3 > &);

 template std::tuple<std::vector<Point< 3 >>,
 std::vector<CellData< 3 >>,
 SubCellData>
 get_coarse_mesh_description(
 const Triangulation< 3 ,  3 > &tria);

 template void
 delete_unused_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &);

 template void
 delete_duplicated_vertices(std::vector<Point< 3 >> &,
 std::vector<CellData< 3 >> &,
 SubCellData &,
 std::vector<unsigned int> &,
 double);

 template void
 invert_all_negative_measure_cells(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 3 >> &);

 template std::size_t
 invert_cells_with_negative_measure(
 const std::vector<Point< 3 >> &,
 std::vector<CellData< 3 >> &);

# if  3  ==  3 
 template void
 consistently_order_cells(std::vector<CellData< 3 >> &);
# endif

 template void
 shift< 3 >(
 const Tensor<1,  3 > &,
 Triangulation< 3 ,  3 > &);

 template void
 scale< 3 >(
 const double,
 Triangulation< 3 ,  3 > &);

# if  3  == 3
 template void
 rotate< 3 >(
 const Tensor<1,  3 , double> &,
 const double,
 Triangulation< 3 ,  3 > &);

 template void
 rotate< 3 >(
 const double,
 const unsigned int,
 Triangulation< 3 ,  3 > &);
# endif

 template void
 distort_random< 3 >(
 const double,
 Triangulation< 3 ,  3 > &,
 const bool,
 const unsigned int);

 template void
 get_face_connectivity_of_cells(
 const Triangulation< 3 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells(
 const Triangulation< 3 ,  3 >
 & triangulation,
 DynamicSparsityPattern &cell_connectivity);

 template void
 get_vertex_connectivity_of_cells_on_level(
 const Triangulation< 3 ,  3 >
 & triangulation,
 const unsigned int level,
 DynamicSparsityPattern &cell_connectivity);

 template void
 partition_triangulation(
 const unsigned int,
 Triangulation< 3 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 Triangulation< 3 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const SparsityPattern &,
 Triangulation< 3 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation(
 const unsigned int,
 const std::vector<unsigned int> &,
 const SparsityPattern &,
 Triangulation< 3 ,  3 > &,
 const SparsityTools::Partitioner);

 template void
 partition_triangulation_zorder(
 const unsigned int,
 Triangulation< 3 ,  3 > &,
 const bool);

 template void
 partition_multigrid_levels(
 Triangulation< 3 ,  3 > &);

 template std::vector<types::subdomain_id>
 get_subdomain_association(
 const Triangulation< 3 ,  3 > &,
 const std::vector<CellId> &);

 template void
 get_subdomain_association(
 const Triangulation< 3 ,  3 > &,
 std::vector<types::subdomain_id> &);

 template unsigned int
 count_cells_with_subdomain_association(
 const Triangulation< 3 ,  3 > &,
 const types::subdomain_id);

 template std::vector<bool>
 get_locally_owned_vertices(
 const Triangulation< 3 ,  3 > &);

 template double
 minimal_cell_diameter(
 const Triangulation< 3 ,  3 >
 &triangulation,
 const Mapping< 3 ,  3 > &);

 template double
 maximal_cell_diameter(
 const Triangulation< 3 ,  3 >
 &triangulation,
 const Mapping< 3 ,  3 > &);

 template std::map<unsigned int, Point< 3 >>
 get_all_vertices_at_boundary(
 const Triangulation< 3 ,  3 > &tria);

 template std::vector<
 std::set<Triangulation< 3 ,
  3 >::active_cell_iterator>>
 vertex_to_cell_map(
 const Triangulation< 3 ,  3 >
 &triangulation);

 template std::vector<std::vector<Tensor<1,  3 >>>
 vertex_to_cell_centers_directions(
 const Triangulation< 3 ,  3 > &mesh,
 const std::vector<std::set<typename Triangulation<
  3 ,
  3 >::active_cell_iterator>> &vertex_to_cells);

# if  3  ==  3 
# if  3  > 1
 template void
 laplace_transform(
 const std::map<unsigned int, Point< 3 >> &new_points,
 Triangulation< 3 > & triangulation,
 const Function< 3 > * coefficient,
 const bool);

 template Triangulation< 3 ,
  3 >::DistortedCellList
 fix_up_distorted_child_cells(
 const Triangulation< 3 ,
  3 >::DistortedCellList
 &distorted_cells,
 Triangulation< 3 ,  3 >
 &triangulation);
# endif
# endif
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(48))
#if  1  >=  1 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 1 ,  1 >(
 Triangulation< 1 ,  1 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 1 ,  1 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 1 ,  1 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 1 ,  1 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 1 ,  1 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 1 ,  1 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 1 ,  1 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(49))
#if  2  >=  1 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 1 ,  2 >(
 Triangulation< 1 ,  2 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 1 ,  2 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 1 ,  2 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 1 ,  2 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 1 ,  2 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 1 ,  2 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 1 ,  2 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(50))
#if  3  >=  1 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 1 ,  3 >(
 Triangulation< 1 ,  3 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 1 ,  3 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 1 ,  3 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 1 ,  3 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 1 ,  3 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 1 ,  3 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 1 ,  3 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(51))
#if  1  >=  2 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 2 ,  1 >(
 Triangulation< 2 ,  1 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 2 ,  1 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 2 ,  1 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 2 ,  1 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 2 ,  1 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 2 ,  1 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 2 ,  1 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(52))
#if  2  >=  2 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 2 ,  2 >(
 Triangulation< 2 ,  2 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 2 ,  2 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 2 ,  2 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 2 ,  2 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 2 ,  2 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 2 ,  2 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 2 ,  2 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(53))
#if  3  >=  2 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 2 ,  3 >(
 Triangulation< 2 ,  3 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 2 ,  3 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 2 ,  3 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 2 ,  3 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 2 ,  3 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 2 ,  3 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 2 ,  3 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(54))
#if  1  >=  3 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 3 ,  1 >(
 Triangulation< 3 ,  1 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 3 ,  1 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 3 ,  1 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 3 ,  1 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 3 ,  1 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 3 ,  1 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 3 ,  1 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(55))
#if  2  >=  3 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 3 ,  2 >(
 Triangulation< 3 ,  2 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 3 ,  2 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 3 ,  2 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 3 ,  2 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 3 ,  2 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 3 ,  2 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 3 ,  2 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(56))
#if  3  >=  3 
 namespace GridTools
 {
 template void
 copy_boundary_to_manifold_id< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const bool);

 template void
 copy_material_to_manifold_id< 3 ,  3 >(
 Triangulation< 3 ,  3 > &,
 const bool);

 template void
 map_boundary_to_manifold_ids< 3 ,  3 >(
 const std::vector<types::boundary_id> &,
 const std::vector<types::manifold_id> &,
 Triangulation< 3 ,  3 > &,
 const std::vector<types::boundary_id> &);

 template void
 assign_co_dimensional_manifold_indicators(
 Triangulation< 3 ,  3 > &,
 const std::function<
 types::manifold_id(const std::set<types::manifold_id> &)> &,
 bool);

 template void
 regularize_corner_cells(
 Triangulation< 3 ,  3 > &,
 double);

 template void
 collect_coinciding_vertices(
 const Triangulation< 3 ,  3 > &,
 std::map<unsigned int, std::vector<unsigned int>> &,
 std::map<unsigned int, unsigned int> &);

 template std::map<unsigned int, std::set<dealii::types::subdomain_id>>
 compute_vertices_with_ghost_neighbors(
 const Triangulation< 3 ,  3 > &);
 }
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(57))
template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 1 ,  1 >(
 Triangulation< 1 >::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 1 ,  1 >(
 Triangulation< 1 > & tria, bool, unsigned int);

 template void
 GridTools::remove_anisotropy< 1 ,  1 >(
 Triangulation< 1 > &, double, unsigned int);

#if  1  < 3
 template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 1 ,
  1  + 1>(
 Triangulation< 1 ,
  1  + 1>::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 1 ,  1  + 1>(
 Triangulation< 1 ,  1  + 1> & tria,
 bool,
 unsigned int);

 template void
 GridTools::remove_anisotropy< 1 ,  1  + 1>(
 Triangulation< 1 ,  1  + 1> &,
 double,
 unsigned int);
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(58))
template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 2 ,  2 >(
 Triangulation< 2 >::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 2 ,  2 >(
 Triangulation< 2 > & tria, bool, unsigned int);

 template void
 GridTools::remove_anisotropy< 2 ,  2 >(
 Triangulation< 2 > &, double, unsigned int);

#if  2  < 3
 template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 2 ,
  2  + 1>(
 Triangulation< 2 ,
  2  + 1>::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 2 ,  2  + 1>(
 Triangulation< 2 ,  2  + 1> & tria,
 bool,
 unsigned int);

 template void
 GridTools::remove_anisotropy< 2 ,  2  + 1>(
 Triangulation< 2 ,  2  + 1> &,
 double,
 unsigned int);
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(59))
template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 3 ,  3 >(
 Triangulation< 3 >::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 3 ,  3 >(
 Triangulation< 3 > & tria, bool, unsigned int);

 template void
 GridTools::remove_anisotropy< 3 ,  3 >(
 Triangulation< 3 > &, double, unsigned int);

#if  3  < 3
 template std::pair<unsigned int, double>
 GridTools::get_longest_direction< 3 ,
  3  + 1>(
 Triangulation< 3 ,
  3  + 1>::active_cell_iterator);

 template void
 GridTools::remove_hanging_nodes< 3 ,  3  + 1>(
 Triangulation< 3 ,  3  + 1> & tria,
 bool,
 unsigned int);

 template void
 GridTools::remove_anisotropy< 3 ,  3  + 1>(
 Triangulation< 3 ,  3  + 1> &,
 double,
 unsigned int);
#endif
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(60))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(61))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(62))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(63))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(64))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(65))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(66))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  LinearAlgebra::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(67))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  LinearAlgebra::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(68))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  LinearAlgebra::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(69))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  LinearAlgebra::Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(70))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  LinearAlgebra::Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(71))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  LinearAlgebra::Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(72))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  LinearAlgebra::distributed::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(73))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  LinearAlgebra::distributed::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(74))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  LinearAlgebra::distributed::Vector<double> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(75))
template class GridTools::MarchingCubeAlgorithm< 1 ,
  LinearAlgebra::distributed::Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(76))
template class GridTools::MarchingCubeAlgorithm< 2 ,
  LinearAlgebra::distributed::Vector<float> >;
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(77))
template class GridTools::MarchingCubeAlgorithm< 3 ,
  LinearAlgebra::distributed::Vector<float> >;
 
#endif

#undef SPLIT_INSTANTIATIONS_CHECK
